<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>memoization on Thomas Tran Portfolio</title>
    <link>https://tranindigo.github.io/tags/memoization/</link>
    <description>Recent content in memoization on Thomas Tran Portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tranindigo.github.io/tags/memoization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Memoization in Ruby and Python</title>
      <link>https://tranindigo.github.io/posts/memoization-in-ruby-and-python/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tranindigo.github.io/posts/memoization-in-ruby-and-python/</guid>
      <description>Memoization refers to remembering results of method calls based on the method inputs and then returning the remembered result rather than computing the result again. You can think of it as a cache for method results but, unlike a cache, memoization doesn&amp;rsquo;t persist across different sessions and instances.
The thing that I really like about Ruby is that it has a streamlined way to memoize method calls. In Ruby, the most common pattern for memoizing a call is using the conditional assignment operator, like so:</description>
    </item>
    
  </channel>
</rss>
